# Example script for getting started with FORCESPRO NLP solver.

# --------------------------------------------------------------------------
# NOTE: This example shows how to define a nonlinear programming problem,
# where all derivative information is automatically generated by
# using the AD tool CasADi. In particular, this example illustrates the
# use of splines inside the problem formulation.
# --------------------------------------------------------------------------

# Solve an optimization problem for a differential drive robot with a
# discrete, nonlinear 1-st order integrator kinematics:

# x_{k+1} = x_{k} + v_{k} * cos(theta_{k}) * \delta_{t}
# y_{k+1} = y_{k} + v_{k} * sin(theta_{k}) * \delta_{t}
# \theta_{k+1} = \theta_{k} + \omega_{k} * \delta_{t}

# x, y, /theta - state vector of the robot,
# v, \omega - linear and angular velocities of the robot,
# \delta_{t} - discretization time

# The robot starts at some initial point and has to reach some goal point.

# Variables are collected stage-wise into
#     z = [v w x y theta].

import shutil
import sys
import forcespro
import numpy as np
import casadi
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation


def continuous_dynamics(X, U):
    """Defines continuos kinematics of the robot

    Args:
        state X = [x, y, theta] 
        input U = [v, w]
    """
    theta = X[2]
    v = U[0]
    w = U[1]
    return casadi.vertcat(v * casadi.cos(theta),
                          v * casadi.sin(theta),
                          w)


def objN(z, p):
    # Reference (goal)robot position
    p_ref_0 = p[0:2]

    # Initial position on the prediction step
    p_0 = p[2:4]

    # Position of the robot on the i-step
    p_N = z[2:4]

    # J_N = casadi.norm_2(p_N - p_ref_0) / casadi.norm_2(p_0 - p_ref_0)

    # / casadi.power(casadi.norm_2(p_0 - p_ref_0), 2)
    J_N = casadi.power(casadi.norm_2(p_N - p_ref_0), 2)

    return J_N


def obj(z):
    """Least square costs on deviating from the goal point and on the inputs v and w
    z = [v, w, x, y, theta]
    """

    v = z[0]
    w = z[1]

    # Cost function at the i-step
    J_i = v**2 + w**2

    return J_i


def generate_pathplanner(gen_solver):
    """Generates and returns a FORCESPRO solver that calculates a path based on
    constraints and dynamics while minimizing an objective function
    """
    # Model Definition
    # ----------------

    # Problem dimensions
    model = forcespro.nlp.SymbolicModel()
    model.N = 20  # horizon length
    model.nvar = 5  # number of variables
    model.neq = 3  # number of equality constraints
    # number of runtime parameters [x_goal y_goal p_rob_0_x p_rob_0_y] Каждый раз когда меняется число пешеходов, необходимо будет переделывать контроллер
    model.npar = 4

    # Objective function
    model.objective = objN
    # model.objectiveN = obj # increased costs for the last stage
    # The function must be able to handle symbolic evaluation,
    # by passing in CasADi symbols. This means certain numpy funcions are not
    # available.

    # We use an explicit RK4 integrator here to discretize continuous dynamics
    integrator_stepsize = 0.1
    model.eq = lambda z: forcespro.nlp.integrate(continuous_dynamics, z[2:5], z[0:2],
                                                 integrator=forcespro.nlp.integrators.RK4,
                                                 stepsize=integrator_stepsize)

    # Indices on LHS of dynamical constraint - for efficiency reasons, make
    # sure the matrix E has structure [0 I] where I is the identity matrix.
    model.E = np.concatenate([np.zeros((3, 2)), np.eye(3)], axis=1)

    # Inequality constraints
    #  upper/lower variable bounds lb <= z <= ub
    #                     inputs   |  states
    #                     v     w  |   x       y     theta
    model.lb = np.array([0,  -2,   -np.inf,  -np.inf, -np.inf])
    model.ub = np.array([+2,  +2,   +np.inf,  +np.inf, +np.inf])

    # Initial condition on vehicle states x
    # use this to specify on which variables initial conditions
    model.xinitidx = range(2, 5)
    # are imposed

    # Solver generation
    # -----------------
    # Set solver options
    codeoptions = forcespro.CodeOptions('FORCESNLPsolver')
    codeoptions.maxit = 1000     # Maximum number of iterations
    codeoptions.printlevel = 2  # Use printlevel = 2 to print progress (but
    #                             not for timings)
    codeoptions.optlevel = 0    # 0 no optimization, 1 optimize for size,
    #                             2 optimize for speed, 3 optimize for size & speed

    codeoptions.cleanup = False
    codeoptions.timing = 1
    # codeoptions.nlp.hessian_approximation = 'bfgs'
    codeoptions.solvemethod = 'SQP_NLP'  # choose the solver method Sequential
    #                              Quadratic Programming
    # codeoptions.nlp.bfgs_init = 2.5*np.identity(5)
    # codeoptions.sqp_nlp.maxqps = 1      # maximum number of quadratic problems to be solved
    # codeoptions.sqp_nlp.reg_hessian = 5e-9 # increase this if exitflag=-8
    # change this to your server or leave uncommented for using the
    # standard embotech server at https://forces.embotech.com
    # codeoptions.server = 'https://forces.embotech.com'

    # Creates code for symbolic model formulation given above, then contacts
    # server to generate new solver
    if gen_solver:
        shutil.rmtree("/home/aleksandr/Research/social_nav_baselines/FORCESNLPsolver",
                      ignore_errors=True, onerror=None)
        solver = model.generate_solver(options=codeoptions)
    else:
        solver = forcespro.nlp.Solver.from_directory(
            "/home/aleksandr/Research/social_nav_baselines/FORCESNLPsolver")

    return model, solver


def plot_data(x, init_state, goal, x_pred_stacked):
    mpl.rcParams['font.size'] = 18
    mpl.rcParams['lines.linewidth'] = 3
    fig, ax = plt.subplots(figsize=[16, 16], facecolor='white')
    ax.set_aspect('equal', adjustable='box')

    x_rob_plt = x[1, :]
    y_rob_plt = x[0, :]
    phi_rob_plt = x[2, :]

    cnt = 0
    r_rob = 0.3
    annotation_offset: np.ndarray = np.array([0, 0.2])

    def animate(i) -> None:
        nonlocal cnt
        ax.clear()
        ax.plot(x_rob_plt[:cnt], y_rob_plt[:cnt],
                linewidth=3, color='blue', label='Robot')
        # plot robot area
        robot_radius_plot = plt.Circle(
            (x_rob_plt[cnt], y_rob_plt[cnt]), r_rob, fill=False, linewidth=5, color='blue')
        robot_fill = plt.Circle(
            (x_rob_plt[cnt], y_rob_plt[cnt]), r_rob, fill=True, color='r', alpha=0.3)
        ax.add_patch(robot_radius_plot)
        ax.add_patch(robot_fill)
        # annotate robot
        robot_coord = (round(x_rob_plt[cnt], 2), (round(y_rob_plt[cnt], 2)))
        ax.annotate(f'Robot: {robot_coord}', robot_coord +
                    np.array([0, r_rob]) + annotation_offset,  ha='center')
        # plot robot goal
        ax.plot(float(goal[1]), float(goal[0]), 'y*', markersize=10)
        # annotate robot goal
        goal_coord = (round(float(goal[1]), 2), round(
            float(goal[0]), 2))
        ax.annotate(f'Goal: {goal_coord}', goal_coord +
                    np.array([0, r_rob]) + 2 * annotation_offset,  ha='center')
        # plot robot start
        ax.plot(float(init_state[0]), float(
            init_state[1]), 'yo', markersize=10)
        # annotate robot start
        start_coord = (round(float(init_state[0]), 2), round(
            float(init_state[1]), 2))
        ax.annotate(f'Start: {start_coord}', start_coord -
                    np.array([0, r_rob]) - annotation_offset,  ha='center')
        # plot robot direction arrow
        ax.arrow(x_rob_plt[cnt], y_rob_plt[cnt], np.sin(
            phi_rob_plt[cnt])*r_rob,  np.cos(phi_rob_plt[cnt])*r_rob, color='b', width=r_rob/5)
        # plot predicted robot trajectory
        ax.plot(x_pred_stacked[cnt, 1, :], x_pred_stacked[cnt,
                0, :], linewidth=1, color='blue', linestyle='dashed')

        ax.grid(True)
        # legend
        ax.set_xlabel('$y$ [m]')
        ax.set_ylabel('$x$ [m]')
        ax.legend()
        ax.set_title("Animation", fontsize=27)
        # increment counter
        cnt = cnt + 1

    print("make_animation: Start")
    frames = len(x_rob_plt)-2
    anim = FuncAnimation(fig, animate, frames=frames,
                         interval=400, repeat=False)
    anim.save(
        "/home/aleksandr/Research/social_nav_baselines/test_forces/test.gif", 'pillow', frames)
    print("make_animation: Done")


def plot_obj(data):
    time = np.linspace(0, len(data)*0.1, len(data))
    fig, ax = plt.subplots(figsize=[16, 16], facecolor='white')
    ax.plot(time, data, linewidth=3)
    ax.grid(True)
    ax.set_xlabel('$t$ [s]')
    ax.set_ylabel('Cost Function, $J$')
    ax.set_title("Cost Function", fontsize=27)
    plt.savefig(
        "/home/aleksandr/Research/social_nav_baselines/test_forces/cost.png")


def main():
    gen_solver = False  # if true, than generate new solver, else use existed

    # generate code for estimator
    model, solver = generate_pathplanner(gen_solver)

    # Simulation
    # ----------
    sim_length = 80  # simulate 8sec

    # Variables for storing simulation data
    x = np.zeros((3, sim_length+1))  # states
    u = np.zeros((2, sim_length))  # inputs

    # Set initial guess to start solver from
    x0i = np.zeros((model.nvar, 1))
    x0 = np.transpose(np.tile(x0i, (1, model.N)))
    # Set initial condition
    init_state = np.array([5, 5, -np.pi*0.5])
    xinit = np.transpose(init_state)
    x[:, 0] = xinit
    # Set goal position
    goal_point = np.array([0, 0])

    # cost-func values
    cost_val = []

    problem = {"x0": x0,
               "xinit": xinit}

    # predicted positions of the robot
    x_pred_stacked = np.zeros((sim_length, model.neq, model.N))

    # Simulation
    for k in range(sim_length):

        # Set initial condition
        problem["xinit"] = x[:, k]

        # Initial position on the prediction step
        p_rob_0 = x[:2, k]

        # Formulate full vector of transmitted parameters
        parameter_vector = np.hstack([goal_point, p_rob_0])

        # Set goal position
        problem["all_parameters"] = np.tile(parameter_vector, (model.N,))

        # Time to solve the NLP!
        # output, exitflag, info = solver.solve(problem)
        output, exitflag, info = solver.solve(problem)

        # Make sure the solver has exited properly.
        assert exitflag == 1, f"bad exitflag {exitflag}"
        sys.stderr.write("FORCESPRO took {} iterations and {} seconds to solve the problem.\n"
                         .format(info.it, info.solvetime))

        # Extract output
        temp = np.zeros((np.max(model.nvar), model.N))
        for i in range(0, model.N):
            temp[:, i] = output['x{0:02d}'.format(i+1)]
        pred_u = temp[0:2, :]
        pred_x = temp[2:5, :]

        # Apply optimized input u of first stage to system and save simulation data
        u[:, k] = pred_u[:, 0]
        x[:, k+1] = np.transpose(model.eq(np.concatenate((u[:, k], x[:, k]))))
        x_pred_stacked[k, :, :] = pred_x

        cost_val.append(info.pobj)

    plot_obj(cost_val)
    plot_data(x, init_state[:2], goal_point, x_pred_stacked)


if __name__ == "__main__":
    main()
